<h1>Javascript Fundamentals</h1>
<div id="container">
    <div class="documentation-item">
        <h3>Variables</h3>
        <p>
            Variables are named elements that can hold values of any JavaScript
            data type.
        </p>
        <p>There are 3 ways to declare variables:</p>
        <ul>
            <li><code class="language-javascript">var</code></li>
            <li><code class="language-javascript">let</code></li>
            <li><code class="language-javascript">const</code></li>
        </ul>

        <h4>var</h4>
        <p>
            <code class="language-javascript">var</code> was the main way of
            declaring variables before
            <code class="language-javascript">let</code> and
            <code class="language-javascript">const</code> was introduced to
            JavaScript
        </p>

        <p>
            The problem with var is that it has either function scope or global
            scope. When used in a function with an if statement for example, the
            variable can be accessed both in the if block and outside of it.<br />
            This concept is called hoisting, and it means that the variable
            declaration is moved to the to of the function.
        </p>

        <p>An example of this behavior:</p>

        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-1">
function test(){
    if (true) {
        // inside if statement
        var myVariable = "hello if statement"
        console.log(myVariable)
    }

    // outside if statement
    console.log(myVariable)
}

test()
</code>
        </pre>
        <button id="run-code-1" class="run-code-button">Run Code</button>
        <div id="output-1" class="output-container">
            <code
                id="output-text-1"
                class="output-text language-javascript"
            ></code>
        </div>

        <h4>let</h4>
        <p>
            <code class="language-javascript">let</code> aims to fix some of the
            problems that var has. <br /><br />
            For example, <code class="language-javascript">let</code> is block
            scoped, which means is is only accessible inside the curly brackets
            <code class="language-javascript">{}</code> in which it is declared.
        </p>

        <p>
            The same example as var but with
            <code class="language-javascript">let</code>
        </p>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-2">
function test(){
    if (true) {
        // inside if statement
        let myVariable = "hello if statement"
        console.log(myVariable)
    }

    // outside if statement
    console.log(myVariable)
}

test()
</code>
        </pre>
        <button id="run-code-2" class="run-code-button">Run Code</button>
        <div id="output-2" class="output-container">
            <code
                id="output-text-2"
                class="output-text language-javascript"
            ></code>
        </div>

        <h4>const</h4>
        <p>
            <code class="language-javascript">const</code> is a constant NOT in
            the value but in the assignment, meaning that it cannot be
            reassigned and thus also HAS to be assigned
        </p>
        <pre>
                        <code class="code-snippet language-javascript" id="code-snippet-3">
// will give error and has to be initialized in const declaration
const test; 
</code>
                    </pre>
        <button id="run-code-3" class="run-code-button">Run Code</button>
        <div id="output-3" class="output-container">
            <code
                id="output-text-3"
                class="output-text language-javascript"
            ></code>
        </div>
        <p>
            We use <code class="language-javascript">const</code> whenever is
            possible, else we fall to using
            <code class="language-javascript">let</code>
        </p>
    </div>
    <div class="documentation-item">
        <h3>Scoping</h3>

        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-4">
// global scope

function someOtherScope(){
    // function scope
}

{
    // block scope
}
</code>
        </pre>

        <p>
            Scope in JavaScript touch on the context in where variables get
            declared and are accessible
        </p>

        <h4>Global Scope</h4>
        <p>Accessible in all other scopes, functions and modules</p>
        <h4>Function Scope</h4>
        <p>
            Only accessible inside the function in which the variable is
            declared
        </p>
        <h4>Block Scope</h4>
        <p>
            Only accessible inside the block
            <code class="language-javascript">{}</code>, can be an if-statement,
            while or for loop to name some examples
        </p>
    </div>
    <div class="documentation-item">
        <h3>Loops</h3>
        <p>
            In modern JavaScript, we always default to using loop methods (<code
                class="language-javascript"
                >forEach, map, filter, sort, find, reduce</code
            >)
            <br />
            <br />
            ONLY use for loops when we need to do finger counting (ex. from
            1-10)

            <br />
            <br />
            With loop methods we get a clear intend on what we are achieving,
            making the code easier to read and maintain. Loop methods are also a
            lot more aesthetically pleasing than a traditional for loop
        </p>

        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-5">
const numbers = [12, 15, 21, 24];

for (let i = 0; i < numbers.length; i++) {
    console.log(numbers[i]);
}

console.log('---------------');

// ALOT simpler code with clear intend
numbers.forEach(number => console.log(number));

</code>
        </pre>
        <button id="run-code-5" class="run-code-button">Run Code</button>
        <div id="output-5" class="output-container">
            <code
                id="output-text-5"
                class="output-text language-javascript"
            ></code>
        </div>

        <p>
            With a traditional for loop we also risk mutating the original list,
            if we are not making a new list and appending to that. With a map
            method, we can assign it to a variable, so we always move forward
            and not accessing lists that has already been manipulated
        </p>

        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-6">
const numbers = [12, 15, 21, 24];

for (index in numbers) {
    numbers[index] = numbers[index] * 2;    
}

const doubledList = numbers.map(number => number * 2);

console.log(numbers);
console.log(doubledList);
</code>
        </pre>
        <button id="run-code-6" class="run-code-button">Run Code</button>
        <div id="output-6" class="output-container">
            <code
                id="output-text-6"
                class="output-text language-javascript"
            ></code>
        </div>
    </div>
    <div class="documentation-item">
        <h3>Functions</h3>
        <h4>Standard Function</h4>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-7">
function getRandomInt(min,max) {
    return Math.floor(Math.random() * (max + 1 - min) + min);
}                
</code>
        </pre>
        <p>
            Standard function definition, with keyword function with a name, and
            potential arguments in the parentheses

            <br /><br />

            Utilizes hoisting, so it can be called from anywhere in the code,
            even before declaration, because all functions defined this way gets
            put at the top of scope in JavaScript
        </p>
        <h4>Anonymous Function</h4>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-8">
const getRandomIntAnonymousFunction = function (min,max) {
    return Math.floor(Math.random() * (max + 1 - min) + min);
};                             
</code>
        </pre>

        <p>
            An anonymous function is a function, that is missing a name. To call
            an anonymous function later, we have to assign it to a variable.
            Typically we use anonymous functions in other functions as
            arguments.
        </p>
        <h4>Arrow Function</h4>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-9">
const getRandomIntArrowFunction = (min, max) => {
    return Math.floor(Math.random() * (max + 1 - min) + min);
};          
</code>
        </pre>
        <p>
            An arrow function is a more concise way of writing a traditional
            function. They don't have names, similar to anonymous functions. If
            the function is a simple return statement, the arrow function don't
            need {}, and can be written on one line, as shown below
        </p>
        <h4>One Line Arrow Function</h4>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-10">
const getRandomIntArrowFunctionOneLiner = 
        (min, max) => Math.floor(Math.random() * (max + 1 - min) + min);
</code>
        </pre>
        <p>
            Arrow Function can be written as 'One Liners', because they don't
            need curly bracket {} if they are a simple return statement. One
            Liners does not explicit need to be on one line, as it can be
            complicated to read if they're long.
        </p>
        <h4>Callback Function</h4>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-11">
                                // string // callback function
function genericActionPerformer(name, genericAction){
    return genericAction(name);
}                

const running = (name) => `${name} is running`;
const runningResult = genericActionPerformer("Alex", running)

console.log(runningResult);            
</code>
        </pre>
        <button id="run-code-11" class="run-code-button">Run Code</button>
        <div id="output-11" class="output-container">
            <code
                id="output-text-11"
                class="output-text language-javascript"
            ></code>
        </div>
        <p>
            Callback Functions are functions that are passed as argument to
            another function. Functions in JavaScript are first class citizens,
            meaning they can be passed as arguments, returned from other
            functions etc. We typically use them in loop methods as arguments,
            in forEach for example, we can use a callback method to manipulate
            each array element.
        </p>
    </div>
    <div class="documentation-item">
        <h3>Types</h3>
        <p>Types in JavaScript:</p>
        <ul>
            <li><code class="language-javascript">Number</code></li>
            <li><code class="language-javascript">String</code></li>
            <li><code class="language-javascript">Boolean</code></li>
            <li><code class="language-javascript">Object</code></li>
            <li><code class="language-javascript">null</code></li>
            <li><code class="language-javascript">undefined</code></li>
            <li><code class="language-javascript">symbol</code></li>
            <li><code class="language-javascript">bigint</code></li>
        </ul>

        <h4>Type Coercion</h4>
        <p>
            Type Coercion in JavaScript is when values automatically gets
            converted to another datatype.
        </p>

        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-12">
const value1 = "10";
const value2 = 7;

const sum = value1 + value2;

console.log(sum);
console.log(typeof(sum))
</code>
        </pre>
        <button id="run-code-12" class="run-code-button">Run Code</button>
        <div id="output-12" class="output-container">
            <code
                id="output-text-12"
                class="output-text language-javascript"
            ></code>
        </div>
        <p>
            In the example above, the
            <code class="language-javascript">value2</code> which is a number
            automatically gets converted to a string, and thus being
            concatenated in the sum variable, which is a string
        </p>
    </div>
    <div class="documentation-item">
        <h3>Asynchrounous Programming</h3>
        <p>
            Asynchrounous Programming lets you run tasks in parallel, so that
            you don't need to wait for an input from a user or a network call to
            an external API etc.

            <br /><br />

            The most common use cases for asynchrounous prorgramming is
        </p>
        <ul>
            <li>Event handlers in browsers</li>
            <li>Network Calls (fetch for example)</li>
            <li>Buffers / Streams</li>
            <li>Working with files / directories</li>
            <li>
                <code class="language-javascript">setTimeout()</code> /
                <code class="language-javascript">setInterval()</code>
            </li>
            <li>Databases</li>
        </ul>

        <p>
            There are 3 ways of achieving asynchrounous programming in
            JavaScript:
        </p>
        <h4>Callbacks</h4>
        <p>
            The problem wtih callbacks is that we risk of sinking into the
            callbck hell when making multiple nested callback functions.
            <br /><br />
            Consider this code:
        </p>

        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-13">
a(function(resA)){
    b(resA, function(resB)){
        c(resB, function(resC)){
            d(resC, function(resD)){
                // .... and so on
            }
        }
    }
}
</code>
        </pre>
        <p>
            The problem with this is that the code becomes a mess really
            quickly, and is also called 'The Pyramid of Doom' <br /><br />
            To fix this, JavaScript introduced Promises.
        </p>
        <h4>Promises</h4>
        <p>
            Promises was brought to JavaScript as an improvement over callbacks.
            <br /><br />
            A Promise can be in two states:
        </p>
        <ul>
            <li>Pending</li>
            <li>
                Fulfilled
                <ol>
                    <li>Resolved</li>
                    <li>Rejected</li>
                </ol>
            </li>
        </ul>
        <p>
            When a Promise gets fulfilled, the function
            <code class="language-javascript">.then()</code> can be called upon
            the object, so you can do further things with the resolved value. If
            a Promise gets rejected, the function
            <code class="language-javascript">.catch()</code> will be called,
            where you can do error handling.
        </p>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-14">
function myPromise() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            try {
                throw "Oh no";
                resolve("Something Good");
            } catch (error) {
                reject("Something Bad");
            }
        }, 3000);
    });
}
</code>
        </pre>
        <h4>Async/Await</h4>
        <p>
            Async/Await is based on Promises, but subjectively more think looks
            cleaner than using
            <code class="language-javascript">.then()</code> and
            <code class="language-javascript">.catch()</code>. <br />
            <br />
            An <code class="language-javascript">async</code> function returns a
            Promise under the hood, and the
            <code class="language-javascript">await</code> is used to wait till
            the Promise resolves.
        </p>
        <pre>
            <code class="code-snippet language-javascript" id="code-snippet-14">
(async function () {
    try {
        const myPromiseResult = await myPromise();
        console.log(myPromiseResult);
    } catch (error) {
        console.log(error);
    }
})();
</code>
        </pre>
        <p>
            Here we have an IIFE (immediately invoked function expression)
            function (pronounced "iffy"), that declares a variable
            'myPromiseResult', that calls our Promise 'myPromise' with the await
            keyword. That way, we stop the execution of going further until the
            Promise is fulfilled and is either resolved or rejected.
        </p>
    </div>
</div>

<script type="module" src="/assets/js/javascriptFundamentals.js"></script>
